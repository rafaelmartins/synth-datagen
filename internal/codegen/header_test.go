package codegen

import (
	"bytes"
	"fmt"
	"strings"
	"testing"

	"rafaelmartins.com/p/synth-datagen/internal/version"
)

func preamble() string {
	return fmt.Sprintf(`// Code generated by "synth-datagen %s"; DO NOT EDIT.

// SPDX-FileCopyrightText: 2022-present Rafael G. Martins <rafael@rafaelmartins.eng.br>
// SPDX-License-Identifier: BSD-3-Clause

#pragma once
`, version.Version)
}

func TestNewHeader(t *testing.T) {
	h := NewHeader()
	if h == nil {
		t.Fatal("NewHeader returned nil")
	}
	if len(h.include) != 0 {
		t.Errorf("expected empty include list, got %d", len(h.include))
	}
	if len(h.macro) != 0 {
		t.Errorf("expected empty macro list, got %d", len(h.macro))
	}
	if len(h.data) != 0 {
		t.Errorf("expected empty data list, got %d", len(h.data))
	}
}

func TestHeaderWriteEmpty(t *testing.T) {
	h := NewHeader()
	var buf bytes.Buffer
	if err := h.Write(&buf); err != nil {
		t.Fatal(err)
	}
	expected := preamble()
	if buf.String() != expected {
		t.Errorf("got:\n%s\nwant:\n%s", buf.String(), expected)
	}
}

func TestHeaderWriteIncludesOnly(t *testing.T) {
	h := NewHeader()
	h.AddInclude("stdint.h", true)
	h.AddInclude("config.h", false)
	var buf bytes.Buffer
	if err := h.Write(&buf); err != nil {
		t.Fatal(err)
	}
	expected := preamble() + "\n#include <stdint.h>\n#include \"config.h\"\n"
	if buf.String() != expected {
		t.Errorf("got:\n%s\nwant:\n%s", buf.String(), expected)
	}
}

func TestHeaderWriteMacrosOnly(t *testing.T) {
	h := NewHeader()
	h.AddMacro("SIZE", int32(10), false, false)
	h.AddMacro("RAW", "val", false, true)
	var buf bytes.Buffer
	if err := h.Write(&buf); err != nil {
		t.Fatal(err)
	}
	expected := preamble() + "\n#define SIZE 10\n#define RAW val\n"
	if buf.String() != expected {
		t.Errorf("got:\n%s\nwant:\n%s", buf.String(), expected)
	}
}

func TestHeaderWriteDataOnly(t *testing.T) {
	h := NewHeader()
	h.AddData("val", int32(42), nil, nil)
	var buf bytes.Buffer
	if err := h.Write(&buf); err != nil {
		t.Fatal(err)
	}
	expected := preamble() + "\nstatic const int32_t val = 0x0000002a;\n"
	if buf.String() != expected {
		t.Errorf("got:\n%s\nwant:\n%s", buf.String(), expected)
	}
}

func TestHeaderWriteFull(t *testing.T) {
	h := NewHeader()
	h.AddInclude("stdint.h", true)
	h.AddMacro("SIZE", int32(3), false, false)
	h.AddData("arr", []int32{10, 20, 30}, nil, nil)
	var buf bytes.Buffer
	if err := h.Write(&buf); err != nil {
		t.Fatal(err)
	}
	got := buf.String()

	// verify section ordering: preamble, includes, macros, data
	preambleEnd := strings.Index(got, "#pragma once\n") + len("#pragma once\n")
	includeIdx := strings.Index(got, "#include")
	macroIdx := strings.Index(got, "#define SIZE")
	dataIdx := strings.Index(got, "static const")

	if preambleEnd <= 0 {
		t.Fatal("preamble not found")
	}
	if includeIdx < preambleEnd {
		t.Error("includes should come after preamble")
	}
	if macroIdx < includeIdx {
		t.Error("macros should come after includes")
	}
	if dataIdx < macroIdx {
		t.Error("data should come after macros")
	}

	// verify specific content
	if !strings.Contains(got, "#include <stdint.h>\n") {
		t.Error("missing include")
	}
	if !strings.Contains(got, "#define SIZE 3\n") {
		t.Error("missing macro")
	}
	if !strings.Contains(got, "static const int32_t arr[3]") {
		t.Error("missing data declaration")
	}
	if !strings.Contains(got, "#define arr_len 3\n") {
		t.Error("missing dimension define")
	}
}

func TestHeaderWriteDataStruct(t *testing.T) {
	type entry struct {
		Name  string
		Value int32
	}
	h := NewHeader()
	h.AddData("item", entry{Name: "test", Value: 42}, nil, nil)
	var buf bytes.Buffer
	if err := h.Write(&buf); err != nil {
		t.Fatal(err)
	}
	got := buf.String()
	if !strings.Contains(got, "static const struct") {
		t.Errorf("expected struct type declaration, got %q", got)
	}
	if !strings.Contains(got, `"test"`) {
		t.Errorf("expected string field value in output, got %q", got)
	}
	if !strings.Contains(got, "0x0000002a") {
		t.Errorf("expected hex int field value in output, got %q", got)
	}
}

func TestHeaderWriteDataFloats(t *testing.T) {
	h := NewHeader()
	h.AddData("f32", float32(3.14), nil, nil)
	var buf bytes.Buffer
	if err := h.Write(&buf); err != nil {
		t.Fatal(err)
	}
	got := buf.String()
	if !strings.Contains(got, "static const float f32") {
		t.Errorf("expected float declaration, got %q", got)
	}
	if !strings.Contains(got, "3.14") {
		t.Errorf("expected float value in output, got %q", got)
	}
}

func TestHeaderWriteMultipleDataSections(t *testing.T) {
	h := NewHeader()
	h.AddData("a", int32(1), nil, nil)
	h.AddData("b", []int32{2, 3}, nil, nil)
	h.AddData("c", "hello", nil, nil)
	var buf bytes.Buffer
	if err := h.Write(&buf); err != nil {
		t.Fatal(err)
	}
	got := buf.String()

	// each data entry should be separated by a blank line (the leading \n)
	if strings.Count(got, "static const") != 3 {
		t.Errorf("expected 3 data declarations in %q", got)
	}
	if !strings.Contains(got, "static const int32_t a ") {
		t.Error("missing int32_t a")
	}
	if !strings.Contains(got, "static const int32_t b[2]") {
		t.Error("missing int32_t b[2]")
	}
	if !strings.Contains(got, "static const char* c ") {
		t.Error("missing char* c")
	}
	if !strings.Contains(got, "#define b_len 2\n") {
		t.Error("missing b_len define")
	}
}

func TestHeaderWriteIncludeDedup(t *testing.T) {
	h := NewHeader()
	h.AddInclude("stdint.h", true)
	h.AddInclude("stdint.h", true)
	h.AddInclude("stdint.h", false)
	var buf bytes.Buffer
	if err := h.Write(&buf); err != nil {
		t.Fatal(err)
	}
	got := buf.String()
	// should only appear once, and as local (system overridden by local)
	if strings.Count(got, "stdint.h") != 1 {
		t.Errorf("expected exactly 1 include for stdint.h, got %q", got)
	}
	if !strings.Contains(got, "#include \"stdint.h\"") {
		t.Error("expected local include after system-to-local override")
	}
}

func TestHeaderWriteMacroError(t *testing.T) {
	h := NewHeader()
	h.AddMacro("BAD", nil, false, false)
	var buf bytes.Buffer
	err := h.Write(&buf)
	if err == nil {
		t.Fatal("expected error")
	}
}

func TestHeaderWriteDataError(t *testing.T) {
	h := NewHeader()
	h.AddData("bad", nil, nil, nil)
	var buf bytes.Buffer
	err := h.Write(&buf)
	if err == nil {
		t.Fatal("expected error")
	}
}
